(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{419:function(t,a,s){"use strict";s.r(a);var e=s(2),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),a("p",[t._v("基本上所有业务系统中的幂等都是各自进行处理，也不是说不能统一处理，统一处理的话需要考虑的内容会比较多。\n核心的业务还是适合业务方自己去处理，比如订单支付，会有个支付记录表，一个订单只能被支付一次，通过支付记录表就可以达到幂等的效果。还有一些不是核心的业务，但是也有幂等的需求。比如网络问题，多次重试。用户点击多次等场景。这种场景下还是需要一个通用的幂等框架来处理，会让业务开发更加简单")]),t._v(" "),a("h2",{attrs:{id:"幂等性定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#幂等性定义"}},[t._v("#")]),t._v(" 幂等性定义")]),t._v(" "),a("p",[t._v("用户对于同一操作发起的一次请求或者多次请求的结果是一致的\n有些操作是天然幂等的：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 查询SQL")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 删除SQL")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 部分更新SQL（如：UPDATE tab1 SET col1 = 1 WHERE col2 = 2）")]),t._v("\n")])])]),a("p",[t._v("有些操作要注意幂等：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 插入SQL")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 部分更新SQL（如：UPDATE tab1 SET col1 = col1 + 1 WHERE col2 = 2）")]),t._v("\n")])])]),a("h2",{attrs:{id:"幂等场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#幂等场景"}},[t._v("#")]),t._v(" 幂等场景")]),t._v(" "),a("ul",[a("li",[t._v("有时我们在填写某些form表单时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是id不一样")]),t._v(" "),a("li",[t._v("我们在项目中为了解决接口超时问题，通常会引入了重试机制。第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），为了避免返回错误的结果，于是会对该请求重试几次，这样也会产生重复的数据")]),t._v(" "),a("li",[t._v("mq消费者在读取消息时，有时候会读取到重复消息，如果处理不好，也会产生重复的数据")])]),t._v(" "),a("h2",{attrs:{id:"幂等方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#幂等方案"}},[t._v("#")]),t._v(" 幂等方案")]),t._v(" "),a("h3",{attrs:{id:"insert前先select"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#insert前先select"}},[t._v("#")]),t._v(" insert前先select")]),t._v(" "),a("p",[t._v("通常情况下，在保存数据的接口中，我们为了防止产生重复数据，一般会在insert前，先根据name或code字段select一下数据。如果该数据已存在，则执行update操作，如果不存在，才执行insert操作")]),t._v(" "),a("p",[a("em",[t._v("该方案可能是平时在防止产生重复数据时，使用最多的方案。但是该方案不适用于并发场景")])]),t._v(" "),a("h3",{attrs:{id:"锁-select"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁-select"}},[t._v("#")]),t._v(" 锁 + select")]),t._v(" "),a("h3",{attrs:{id:"唯一索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#唯一索引"}},[t._v("#")]),t._v(" 唯一索引")]),t._v(" "),a("h3",{attrs:{id:"使用去重表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用去重表"}},[t._v("#")]),t._v(" 使用去重表")]),t._v(" "),a("p",[t._v("例如唯一码收货，每扫一个唯一码，就发送事件给采购，收货单中就会多一个商品，然后通知交易已收货；如果采购长时间不通知交易，交易会重试，会有幂等问题；收货单中增加一个商品的同时，向去重表中插入一个唯一码，去重表唯一码是唯一索引")]),t._v(" "),a("h3",{attrs:{id:"状态机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态机"}},[t._v("#")]),t._v(" 状态机")]),t._v(" "),a("p",[t._v("很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态。如果这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性")]),t._v(" "),a("h3",{attrs:{id:"token方案-update可以用这种方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#token方案-update可以用这种方案"}},[t._v("#")]),t._v(" token方案（update可以用这种方案）")]),t._v(" "),a("p",[t._v("这种方式分成两个阶段：申请token阶段和支付阶段。")]),t._v(" "),a("ul",[a("li",[t._v("第一阶段：在进入到提交订单页面之前，需要订单系统根据用户信息向支付系统发起一次申请token的请求，支付系统将token保存到Redis缓存中，为第二阶段支付使用")]),t._v(" "),a("li",[t._v("第二阶段：订单系统拿着申请到的token发起支付请求，支付系统会检查Redis中是否存在该token，如果存在，表示第一次发起支付请求，删除缓存中token后开始支付逻辑处理；如果缓存中不存在，表示非法请求")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/375413/1618648286176-10633dbf-297b-46df-ba6d-3b538e5f2673.png#clientId=u4054849a-93ef-4&from=paste&height=480&id=u5bc0ad3e&originHeight=480&originWidth=776&originalType=binary&size=105596&status=done&style=none&taskId=u1e0986c7-455d-4ed6-8695-718b910f7d4&width=776",alt:""}})])])}),[],!1,null,null,null);a.default=r.exports}}]);