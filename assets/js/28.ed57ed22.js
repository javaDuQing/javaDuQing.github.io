(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{428:function(e,t,a){"use strict";a.r(t);var i=a(2),n=Object(i.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("hr"),e._v(" "),t("p",[t("strong",[t("em",[e._v("from：《从 0 开始学架构》")])])]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("相比于高性能、高可用架构模式在最近几十年的迅猛发展来说，可扩展架构模式的发展可以说是步履蹒跚，最近几年火热的微服务模式算是可扩展模式发展历史中为数不多的亮点，但这也导致了现在谈可扩展的时候必谈微服务，甚至微服务架构都成了架构设计的银弹，高性能也用微服务、高可用也用微服务，很多时候这样的架构设计看起来高大上，实际上是大炮打蚊子，违背了架构设计的“合适原则”和“简单原则”")]),e._v(" "),t("p",[e._v("为了帮助你在实践中更好的进行可扩展架构设计，我将分别介绍几种可扩展架构模式，指出每种架构模式的关键点和优缺点。今天我来介绍传统的可扩展模式，包括分层架构和SOA，后面还会介绍微服务架构")]),e._v(" "),t("h2",{attrs:{id:"分层架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分层架构"}},[e._v("#")]),e._v(" 分层架构")]),e._v(" "),t("p",[e._v("分层架构是很常见的架构模式，它也叫 N 层架构，通常情况下，N 至少是 2 层。例如，C/S 架构、B/S 架构。常见的是 3 层架构（例如，MVC、MVP 架构）、4 层架构，5 层架构的比较少见，一般是比较复杂的系统才会达到或者超过 5 层，比如操作系统内核架构\n按照分层架构进行设计时，根据不同的划分维度和对象，可以得到多种不同的分层架构：")]),e._v(" "),t("ol",[t("li",[e._v("C/S 架构、B/S 架构")])]),e._v(" "),t("p",[e._v("划分的对象是整个业务系统，划分的维度是用户交互，即将和用户交互的部分独立为一层，支撑用户交互的后台作为另外一层。例如，下面是 C/S 架构结构图：\n"),t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650425329917-cbe435d5-7975-454d-a83b-b425f7cd881a.png#clientId=u673669c7-af24-4&from=paste&height=230&id=ue160f269&name=image.png&originHeight=412&originWidth=676&originalType=binary&ratio=1&rotation=0&showTitle=false&size=142271&status=done&style=none&taskId=u8107a5bc-f431-4642-b36a-d6276d88ecf&title=&width=378",alt:"image.png"}})]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("MVC 架构、MVP 架构")])]),e._v(" "),t("p",[e._v("划分的对象是单个业务子系统，划分的维度是职责，将不同的职责划分到独立层，但各层的依赖关系比较灵活。例如，MVC 架构中各层之间是两两交互的：\n"),t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650425377205-e5074ecb-93d9-48ac-a2b5-68de9395dfd7.png#clientId=u673669c7-af24-4&from=paste&height=163&id=u80998d89&name=image.png&originHeight=346&originWidth=624&originalType=binary&ratio=1&rotation=0&showTitle=false&size=72778&status=done&style=none&taskId=u9e86008c-806a-423f-9771-2d933e9bd43&title=&width=294",alt:"image.png"}})]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("逻辑分层架构")])]),e._v(" "),t("p",[e._v("划分的对象可以是单个业务子系统，也可以是整个业务系统，划分的维度也是职责。虽然都是基于职责划分，但逻辑分层架构和 MVC 架构、MVP 架构的不同点在于，逻辑分层架构中的层是自顶向下依赖的。典型的有操作系统内核架构、TCP/IP 架构。例如，下面是 Android 操作系统架构图：\n"),t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650425446956-6f1cec45-f721-4f1e-93bb-3ce833f1e714.png#clientId=u673669c7-af24-4&from=paste&height=986&id=u8a08b3f9&name=image.png&originHeight=986&originWidth=1502&originalType=binary&ratio=1&rotation=0&showTitle=false&size=883127&status=done&style=none&taskId=u09ce102a-5aaa-4e64-bbed-24b8574080c&title=&width=1502",alt:"image.png"}}),e._v("\n银行系统架构图：\n"),t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650425485822-35c3c395-4987-4c67-b5c4-74fb0fa8a82b.png#clientId=u673669c7-af24-4&from=paste&height=326&id=u81620658&name=image.png&originHeight=676&originWidth=638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=261286&status=done&style=none&taskId=ua5fb9e68-8e6c-4870-94b1-ca2dd33be74&title=&width=308",alt:"image.png"}}),e._v("\n无论采取何种分层维度，分层架构设计最核心的一点就是需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构，这也是分层不能分太多层的原因。否则如果两个层的差异不明显，就会出现程序员小明认为某个功能应该放在 A 层，而程序员老王却认为同样的功能应该放在B层，这样会导致分层混乱。如果这样的架构进入实际开发落地，则 A 层和 B 层就会乱成一锅粥，也就失去了分层的意义")]),e._v(" "),t("p",[e._v("分层架构之所以能够较好地支撑系统扩展，本质在于隔离关注点（separation of concerns），即每个层中的组件只会处理本层的逻辑。比如说，展示层只需要处理展示逻辑，业务层中只需要处理业务逻辑，这样我们在扩展某层时，其他层是不受影响的，通过这种方式可以支撑系统在某层上快速扩展。例如，Linux 内核如果要增加一个新的文件系统，则只需要修改文件存储层即可，其他内核层无须变动")]),e._v(" "),t("p",[e._v("当然，并不是简单地分层就一定能够实现隔离关注点从而支撑快速扩展，分层时要保证层与层之间的依赖是稳定的，才能真正支撑快速扩展。例如，Linux 内核为了支撑不同的文件系统格式，抽象了VFS文件系统接口，架构图如下：\n"),t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650425618591-c26e1140-6a9b-44cd-a96a-2cc662e0371a.png#clientId=u6cad699f-e564-4&from=paste&height=373&id=u1c82ea11&name=image.png&originHeight=590&originWidth=738&originalType=binary&ratio=1&rotation=0&showTitle=false&size=200428&status=done&style=none&taskId=u51222bd6-ceaf-4d83-923a-3f5c8bbde89&title=&width=466",alt:"image.png"}}),e._v("\n如果没有 VFS，只是简单地将 ext2、ext3、reiser 等文件系统划为“文件系统层”，那么这个分层是达不到支撑可扩展的目的的。因为增加一个新的文件系统后，所有基于文件系统的功能都要适配新的文件系统接口；而有了 VFS 后，只需要 VFS 适配新的文件系统接口，其他基于文件系统的功能是依赖 VFS 的，不会受到影响")]),e._v(" "),t("p",[e._v("对于操作系统这类复杂的系统，接口本身也可以成为独立的一层。例如，我们把 VFS 独立为一层是完全可以的。而对于一个简单的业务系统，接口可能就是Java语言上的几个interface定义，这种情况下如果独立为一层，看起来可能就比较重了。例如，经典的J2EE分层架构中，Presentation Layer 和 Business Layer 之间如果硬要拆分一个独立的接口层，则显得有点多余了")]),e._v(" "),t("p",[e._v("分层结构的另外一个特点就是层层传递，也就是说一旦分层确定，整个业务流程是按照层进行依次传递的，不能在层之间进行跳跃。最简单的 C/S 结构，用户必须先使用 C 层，然后 C 层再传递到 S 层，用户是不能直接访问 S 层的。传统的 J2EE 4 层架构，收到请求后，必须按照下面的方式传递请求：\n"),t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650425757413-d32caf52-9bb9-4ab9-8f34-bf56b5bdcd24.png#clientId=u6cad699f-e564-4&from=paste&height=352&id=ud369fa31&name=image.png&originHeight=638&originWidth=922&originalType=binary&ratio=1&rotation=0&showTitle=false&size=277283&status=done&style=none&taskId=u39e11d78-5d02-4650-8982-2ff09f758b9&title=&width=509",alt:"image.png"}}),e._v("\n分层结构的这种约束，好处在于强制将分层依赖限定为两两依赖，降低了整体系统复杂度。例如，Business Layer被Presentation Layer 依赖，自己只依赖 Persistence Layer 但分层结构的代价就是冗余，也就是说，不管这个业务有多么简单，每层都必须要参与处理（算是一个缺点）")]),e._v(" "),t("h2",{attrs:{id:"soa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#soa"}},[e._v("#")]),e._v(" SOA")]),e._v(" "),t("p",[e._v("SOA 与 微服务的区别可以先看看这个：\n"),t("a",{attrs:{href:"https://www.yuque.com/go/doc/66687995?view=doc_embed",target:"_blank",rel:"noopener noreferrer"}},[e._v("概念理解"),t("OutboundLink")],1),e._v("\nSOA 的全称是 Service Oriented Architecture，中文翻译为“面向服务的架构”，诞生于上世纪 90 年代，1996 年Gartner 的两位分析师 Roy W. Schulte和Yefm V. Natis 发表了第一个 SOA 的报告\n2005年，Gartner 预言：到了 2008 年，SOA 将成为 80% 的开发项目的基础。历史证明这个预言并不十分靠谱，SOA 虽然在很多企业成功推广，但没有达到占有绝对优势的地步。SOA 更多是在传统企业（例如，制造业、金融业等）落地和推广，在互联网行业并没有大规模地实践和推广。互联网行业推行SOA最早的应该是亚马逊，得益于杰弗·贝索斯的远见卓识，亚马逊内部的系统都以服务的方式构造，间接地促使了后来的亚马逊云计算技术的出现")]),e._v(" "),t("p",[e._v("SOA 出现的背景是企业内部的IT系统重复建设且效率低下，主要体现在：\n企业各部门有独立的IT系统，比如人力资源系统、财务系统、销售系统，这些系统可能都涉及人员管理，各IT系统都需要重复开发人员管理的功能。例如，某个员工离职后，需要分别到上述三个系统中删除员工的权限。各个独立的IT系统可能采购于不同的供应商，实现技术不同，企业自己也不太可能基于这些系统进行重构")]),e._v(" "),t("p",[e._v("随着业务的发展，复杂度越来越高，更多的流程和业务需要多个IT系统合作完成。由于各个独立的IT系统没有标准的实现方式（例如，人力资源系统用Java开发，对外提供RPC；而财务系统用C#开发，对外提供SOAP协议），每次开发新的流程和业务，都需要协调大量的IT系统，同时定制开发，效率很低。为了应对传统IT系统存在的问题，SOA提出了3个关键概念：")]),e._v(" "),t("ol",[t("li",[e._v("服务：所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发；服务可大可小，可简单也可复杂。例如，人力资源管理可以是一项服务，包括人员基本信息管理、请假管理、组织结构管理等功能；而人员基本信息管理也可以作为一项独立的服务，组织结构管理也可以作为一项独立的服务。到底是划分为粗粒度的服务，还是划分为细粒度的服务，需要根据企业的实际情况进行判断")]),e._v(" "),t("li",[e._v("ESB：ESB 的全称是 Enterprise Service Bus，中文翻译为“企业服务总线”。从名字就可以看出，ESB 参考了计算机总线的概念。计算机中的总线将各个不同的设备连接在一起，ESB 将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。SOA 使用ESB 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通")]),e._v(" "),t("li",[e._v("松耦合：松耦合的目的是减少各个服务间的依赖和互相影响。因为采用 SOA 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。但实际上真正做到松耦合并没有那么容易，要做到完全后向兼容，是一项复杂的任务")])]),e._v(" "),t("p",[e._v("典型的 SOA 架构样例如下：\n"),t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650426338091-cbc40ece-e23f-4b4c-bb18-633b392a9827.png#clientId=u1a9dcbfe-9a67-4&from=paste&height=343&id=u1f6c363e&name=image.png&originHeight=540&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=434300&status=done&style=none&taskId=ude7ad7b4-963e-4995-8a69-a5a964b9fec&title=&width=542",alt:"image.png"}}),e._v("\nSOA 架构是比较高层级的架构设计理念，一般情况下我们可以说某个企业采用了 SOA 的架构来构建 IT 系统，但不会说某个独立的系统采用了 SOA 架构。例如，某企业采用 SOA 架构，将系统分为“人力资源管理服务”“考勤服务”“财务服务”")]),e._v(" "),t("p",[e._v("SOA 解决了传统IT系统重复建设和扩展效率低的问题，但其本身也引入了更多的复杂性。SOA 最广为人诟病的就是 ESB，ESB 需要实现与各种系统间的协议转换、数据转换、透明的动态路由等功能。例如，下图中 ESB 将JSON 转换为 Java ：\n"),t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650426419888-2c9b278d-b937-40eb-b17d-a1a1de1cc8a4.png#clientId=u1a9dcbfe-9a67-4&from=paste&height=197&id=u9770815e&name=image.png&originHeight=348&originWidth=1066&originalType=binary&ratio=1&rotation=0&showTitle=false&size=280095&status=done&style=none&taskId=u09b6027b-34ab-4798-9925-3f648154f94&title=&width=603",alt:"image.png"}}),e._v("\n下图中 ESB 将 REST 协议转换为 RMI 和 AMQP 两个不同的协议：\n"),t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650426454658-9ad76f0b-6d6f-4a7d-a50e-871dae268720.png#clientId=u1a9dcbfe-9a67-4&from=paste&height=191&id=u05d132ab&name=image.png&originHeight=332&originWidth=1072&originalType=binary&ratio=1&rotation=0&showTitle=false&size=220073&status=done&style=none&taskId=u3d96e284-3142-42ad-bd56-dcb95474ba0&title=&width=618",alt:"image.png"}}),e._v("\nESB 虽然功能强大，但现实中的协议有很多种，如 JMS、WS、HTTP、RPC等，数据格式也有很多种，如XML、JSON、二进制、HTML 等。ESB 要完成这么多协议和数据格式的互相转换，工作量和复杂度都很大，而且这种转换是需要耗费大量计算性能的，当 ESB 承载的消息太多时，ESB 本身会成为整个系统的性能瓶颈")]),e._v(" "),t("p",[e._v("当然，SOA 的 ESB 设计也是无奈之举。回想一下 SOA 的提出背景就可以发现，企业在应用 SOA 时，各种异构的IT系统都已经存在很多年了，完全重写或者按照统一标准进行改造的成本是非常大的，只能通过 ESB 方式去适配已经存在的各种异构系统")])])}),[],!1,null,null,null);t.default=n.exports}}]);