(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{413:function(t,a,e){"use strict";e.r(a);var i=e(2),r=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("ul",[a("li",[t._v("分布式理论的 CP -> 刚性事务（遵循 ACID，对数据要求强一致性）")]),t._v(" "),a("li",[t._v("分布式理论的 AP + BASE -> 柔性事务（遵循 BASE，允许一定时间内不同节点的数据不一致，但要求最终一致）")])]),t._v(" "),a("h2",{attrs:{id:"分布式事务体系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务体系"}},[t._v("#")]),t._v(" 分布式事务体系")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676462111777-82cc06f7-d60a-44db-bfcb-8a1bb7b173b1.png#averageHue=%23faf5ef&clientId=ua251f530-58bd-4&from=paste&height=321&id=u05630468&name=image.png&originHeight=642&originWidth=1334&originalType=binary&ratio=2&rotation=0&showTitle=false&size=105947&status=done&style=none&taskId=u636b22d9-2a69-4644-9456-766d8619163&title=&width=667",alt:"image.png"}})]),t._v(" "),a("p",[a("strong",[t._v("刚性事务")]),t._v("：分布式理论的 CP，遵循 ACID，对数据要求强一致性。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("XA协议")]),t._v(" 是一个基于数据库层面的分布式事务协议，其分为两部分："),a("strong",[t._v("事务管理器（Transaction Manager）和本地资源管理器（Resource Manager）")]),t._v("。事务管理器作为一个全局的调度者，负责对各个本地资源管理器统一号令提交或者回滚。主流的诸如 Oracle、MySQL 等数据库均已实现了 XA 接口。\n"),a("ul",[a("li",[a("strong",[t._v("二阶提交协议（2PC）")]),t._v(": 根据 XA 协议衍生出来而来; 引入一个作为协调者的组件来统一掌控所有参与者的操作结果并最终指示这些节点是否要把操作结果进行真正的提交; 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。所谓的两个阶段是指：第一阶段：准备阶段 (投票阶段) 和第二阶段：提交阶段（执行阶段）")]),t._v(" "),a("li",[a("strong",[t._v("三阶提交协议（3PC）")]),t._v(": 是对两段提交（2PC）的一种升级优化，"),a("strong",[t._v("3PC 在 2PC 的第一阶段和第二阶段中插入一个准备阶段")]),t._v("。保证了在最后提交阶段之前，各参与者节点的状态都一致。同时在协调者和参与者中都引入超时机制，当参与者各种原因未收到协调者的 commit 请求后，会对本地事务进行 commit，不会一直阻塞等待，解决了 2PC 的单点故障问题，但 3PC 还是没能从根本上解决数据一致性的问题。")])])]),t._v(" "),a("li",[a("strong",[t._v("Java事务规范")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("JTA")]),t._v("：Java 事务 API（Java Transaction API）是一个 Java 企业版的应用程序接口，在 Java 环境中，允许完成跨越多个 XA 资源的分布式事务。")]),t._v(" "),a("li",[a("strong",[t._v("JTS")]),t._v("：Java 事务服务（Java Transaction Service）是 J2EE 平台提供了分布式事务服务的具体实现规范，j2ee 服务器提供商根据 JTS 规范实现事务并提供 JTA 接口。")])])])]),t._v(" "),a("p",[a("strong",[t._v("柔性事务")]),t._v("：分布式理论的 AP，遵循 BASE，允许一定时间内不同节点的数据不一致，但要求最终一致。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("基于业务层")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("TCC")]),t._v(": TCC（Try-Confirm-Cancel）又被称补偿事务，TCC 与 2PC 的思想很相似，事务处理流程也很相似，但 2PC 是应用于在 DB 层面，TCC 则可以理解为在应用层面的 2PC，是需要我们编写业务逻辑来实现。")]),t._v(" "),a("li",[a("strong",[t._v("SAGA")]),t._v("：Saga 是由一系列的本地事务构成。每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发 Saga 中的下一个本地事务的执行。如果一个本地事务因为某些业务规则无法满足而失败，Saga 会执行在这个失败的事务之前成功提交的所有事务的补偿操作。Saga 的实现有很多种方式，其中最流行的两种方式是：基于事件的方式和基于命令的方式。")])])]),t._v(" "),a("li",[a("strong",[t._v("最终一致性")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("消息表")]),t._v("：本地消息表的方案最初是由 eBay 提出，核心思路是将分布式事务拆分成本地事务进行处理。")]),t._v(" "),a("li",[a("strong",[t._v("消息队列")]),t._v("：基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。")]),t._v(" "),a("li",[a("strong",[t._v("最大努力通知")]),t._v("：最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到消息，此时可以调用事务主动方提供的消息校对的接口主动获取。")])])])]),t._v(" "),a("h2",{attrs:{id:"_2pc-3pc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2pc-3pc"}},[t._v("#")]),t._v(" 2PC 3PC")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/distributed/2-stage-commit.html"}},[t._v("请看这里")])],1),t._v(" "),a("h2",{attrs:{id:"tcc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcc"}},[t._v("#")]),t._v(" TCC")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"title"}),a("p",[t._v("TCC（Try-Confirm-Cancel）又被称补偿事务，TCC 与 2PC 的思想很相似，事务处理流程也很相似，但"),a("strong",[t._v("2PC 是应用于在 DB 层面，TCC 则可以理解为在应用层面的 2PC，是需要我们编写业务逻辑来实现")]),t._v("。")])]),a("p",[t._v("TCC 它的核心思想是：针对每个操作都要注册一个与其对应的确认（Try）和补偿（Cancel）。")]),t._v(" "),a("p",[t._v("还拿下单扣库存解释下它的三个操作：")]),t._v(" "),a("ul",[a("li",[t._v("Try 阶段主要是对业务系统做检测及资源预留（例如像扣库存，资源预留可以使用 select...for update的方式锁住那条库存；或者在库存表中增加一个占用库存的字段）")]),t._v(" "),a("li",[t._v("Confirm 阶段主要是对业务系统做确认提交")]),t._v(" "),a("li",[t._v("Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。")])]),t._v(" "),a("p",[t._v("举个例子，假入 Bob 要向 Smith 转账，思路大概是：我们有一个本地方法，里面依次调用 1、首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。 2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。 3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676462693807-7b4c5652-1a76-4925-a703-12b8611cb4df.png#averageHue=%231fc123&clientId=ua251f530-58bd-4&from=paste&height=414&id=u25f9e95c&name=image.png&originHeight=827&originWidth=1280&originalType=binary&ratio=2&rotation=0&showTitle=false&size=143486&status=done&style=none&taskId=u4f7a4400-2b8a-404f-b2c6-a8763e0b376&title=&width=640",alt:"image.png"}})]),t._v(" "),a("h3",{attrs:{id:"tcc-三大问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcc-三大问题"}},[t._v("#")]),t._v(" TCC 三大问题")]),t._v(" "),a("ul",[a("li",[t._v("空回滚")])]),t._v(" "),a("p",[t._v("当一个分支事务所在的服务发生宕机或者网络异常导致调用失败，并未执行 try 方法，当恢复后事务执行回滚操作就会调用此分支事务的 cancel 方法,如果 cancel 方法不能处理此种情况就会出现空回滚。")]),t._v(" "),a("p",[t._v("是否出现空回滚，我们需要需要判断是否执行了 try 方法，如果执行了就没有空回滚。解决方法就是当主业务发起事务时，生成一个全局事务记录，并生成一个全局唯一 ID，贯穿整个事务，再创建一张分支事务记录表，用于记录分支事务，try 执行时将全局事务 ID 和分支事务 ID 存入分支事务表中，表示执行了 try 阶段，当 cancel 执行时，先判断表中是否有该全局事务 ID 的数据，如果有则回滚，否则不做任何操作。比如 seata 的 AT模式中就有分支事务表。")]),t._v(" "),a("ul",[a("li",[t._v("幂等问题")])]),t._v(" "),a("p",[t._v("由于服务宕机或者网络问题，方法的调用可能出现超时，为了保证事务正常执行我们往往会加入重试的机制，因此就需要保证 confirm 和 cancel 阶段操作的幂等性。")]),t._v(" "),a("p",[t._v("我们可以在分支事务记录表中增加事务执行状态，每次执行 confirm 和 cancel 方法时都查询该事务的执行状态，以此判断事务的幂等性。")]),t._v(" "),a("ul",[a("li",[t._v("悬挂问题")])]),t._v(" "),a("p",[t._v("TCC 中，在调用 try 之前会先注册分支事务，注册分支事务之后，调用出现超时，此时 try 请求还未到达对应的服务，因为调用超时了，所以会执行 cancel 调用，此时 cancel 已经执行完了，然而这个时候 try 请求到达了，这个时候执行了 try 之后就没有后续的操作了，就会导致资源挂起，无法释放。")]),t._v(" "),a("p",[t._v("执行 try 方法时我们可以判断 confirm 或者 cancel 方法是否执行，如果执行了那么就不执行 try 阶段。同样借助分支事务表中事务的执行状态。如果已经执行了 confirm 或者 cance l那么 try 就执行。")]),t._v(" "),a("h2",{attrs:{id:"saga-事务-长事务解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#saga-事务-长事务解决方案"}},[t._v("#")]),t._v(" Saga 事务（长事务解决方案）")]),t._v(" "),a("p",[t._v("Saga 是由一系列的本地事务构成。每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发Saga 中的下一个本地事务的执行。如果一个本地事务因为某些业务规则无法满足而失败，Saga 会执行在这个失败的事务之前成功提交的所有事务的补偿操作。\nSaga 的实现有很多种方式，其中最流行的两种方式是：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("基于事件的方式")]),t._v("。这种方式没有协调中心，整个模式的工作方式就像舞蹈一样，各个舞蹈演员按照预先编排的动作和走位各自表演，最终形成一只舞蹈。处于当前 Saga 下的各个服务，会产生某类事件，或者监听其它服务产生的事件并决定是否需要针对监听到的事件做出响应。")]),t._v(" "),a("li",[a("strong",[t._v("基于命令的方式")]),t._v("。这种方式的工作形式就像一只乐队，由一个指挥家（协调中心）来协调大家的工作。协调中心来告诉 Saga 的参与方应该执行哪一个本地事务。")])]),t._v(" "),a("p",[t._v("假设一个完整的订单流程包含了如下几个服务：")]),t._v(" "),a("ol",[a("li",[t._v("Order Service：订单服务")]),t._v(" "),a("li",[t._v("Payment Service：支付服务")]),t._v(" "),a("li",[t._v("Stock Service：库存服务")]),t._v(" "),a("li",[t._v("Delivery Service：物流服务")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676464520276-7399ed9c-e7b6-4918-9b1f-1939c00307fc.png#averageHue=%23fcfcfb&clientId=u15e6aded-3b44-4&from=paste&height=314&id=uc284fda7&name=image.png&originHeight=627&originWidth=1024&originalType=binary&ratio=2&rotation=0&showTitle=false&size=106132&status=done&style=none&taskId=u47d0da91-1721-42e1-a418-f9eb5492391&title=&width=512",alt:"image.png"}})]),t._v(" "),a("h3",{attrs:{id:"基于事件的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于事件的方式"}},[t._v("#")]),t._v(" 基于事件的方式")]),t._v(" "),a("p",[t._v("在基于事件的方式中，第一个服务执行完本地事务之后，会产生一个事件。其它服务会监听这个事件，触发该服务本地事务的执行，并产生新的事件。")]),t._v(" "),a("p",[t._v("采用基于事件的saga模式的订单处理流程如下：\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676464639816-84e04760-511d-4a46-a5d5-8d86925f33dc.png#averageHue=%23fafafa&clientId=udf6c8132-4122-4&from=paste&height=498&id=u311d9c62&name=image.png&originHeight=996&originWidth=936&originalType=binary&ratio=2&rotation=0&showTitle=false&size=216863&status=done&style=none&taskId=u9c3eb8a1-aca9-441b-bcde-b8b39331d98&title=&width=468",alt:"image.png"}})]),t._v(" "),a("ul",[a("li",[t._v('订单服务创建一笔新订单，将订单状态设置为"待处理"，产生事件ORDER_CREATED_EVENT。')]),t._v(" "),a("li",[t._v("支付服务监听ORDER_CREATED_EVENT，完成扣款并产生事件BILLED_ORDER_EVENT。")]),t._v(" "),a("li",[t._v("库存服务监听BILLED_ORDER_EVENT，完成库存扣减和备货，产生事件ORDER_PREPARED_EVENT。")]),t._v(" "),a("li",[t._v("物流服务监听ORDER_PREPARED_EVENT，完成商品配送，产生事件ORDER_DELIVERED_EVENT。")]),t._v(" "),a("li",[t._v('订单服务监听ORDER_DELIVERED_EVENT，将订单状态更新为"完成"。')])]),t._v(" "),a("p",[t._v('在这个流程中，订单服务很可能还会监听BILLED_ORDER_EVENT，ORDER_PREPARED_EVENT来完成订单状态的实时更新。将订单状态分别更新为"已经支付"和"已经出库"等状态来及时反映订单的最新状态。')]),t._v(" "),a("h4",{attrs:{id:"该模式下分布式事务的回滚"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#该模式下分布式事务的回滚"}},[t._v("#")]),t._v(" "),a("strong",[t._v("该模式下分布式事务的回滚")])]),t._v(" "),a("p",[t._v("为了在异常情况下回滚整个分布式事务，我们需要为相关服务提供补偿操作接口。")]),t._v(" "),a("p",[t._v("假设库存服务由于库存不足没能正确完成备货，我们可以按照下面的流程来回滚整个 Saga 事务：\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676464797551-dcc3b9c4-d92e-41b5-abce-4b03807301e1.png#averageHue=%23fafafa&clientId=udf6c8132-4122-4&from=paste&height=368&id=u0977fb7b&name=image.png&originHeight=736&originWidth=1074&originalType=binary&ratio=2&rotation=0&showTitle=false&size=184686&status=done&style=none&taskId=u81b42400-bccb-43d0-bf8a-1ef82b3dbdb&title=&width=537",alt:"image.png"}})]),t._v(" "),a("ol",[a("li",[t._v("库存服务产生事件PRODUCT_OUT_OF_STOCK_EVENT。")]),t._v(" "),a("li",[t._v("订单服务和支付服务都会监听该事件并做出响应：")]),t._v(" "),a("li",[t._v("支付服务完成退款。")]),t._v(" "),a("li",[t._v('订单服务将订单状态设置为"失败"。')])]),t._v(" "),a("h4",{attrs:{id:"基于事件方式的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于事件方式的优缺点"}},[t._v("#")]),t._v(" 基于事件方式的优缺点")]),t._v(" "),a("p",[a("strong",[t._v("优点")]),t._v("：简单且容易理解。各参与方相互之间无直接沟通，完全解耦。这种方式比较适合整个分布式事务只有 2-4个步骤的情形。")]),t._v(" "),a("p",[a("strong",[t._v("缺点")]),t._v("：这种方式如果涉及比较多的业务参与方，则比较容易失控。各业务参与方可随意监听对方的消息，以至于最后没人知道到底有哪些系统在监听哪些消息。更悲催的是，这个模式还可能产生环形监听，也就是两个业务方相互监听对方所产生的事件。")]),t._v(" "),a("p",[t._v("接下来，我们将介绍如何使用命令的方式来克服上面提到的缺点")]),t._v(" "),a("h3",{attrs:{id:"基于命令的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于命令的方式"}},[t._v("#")]),t._v(" 基于命令的方式")]),t._v(" "),a("p",[t._v("在基于命令的方式中，我们会定义一个新的服务，这个服务扮演的角色就和一支交响乐乐队的指挥一样，告诉各个业务参与方，在什么时候做什么事情。我们管这个新服务叫做协调中心。协调中心通过命令/回复的方式来和Saga中其它服务进行交互。")]),t._v(" "),a("p",[t._v("我们继续以之前的订单流程来举例。下图中的 Order Saga Orchestrator 就是新引入的协调中心。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676464969101-e8390032-9b27-4366-a995-a41ec88eef71.png#averageHue=%23fafaf9&clientId=udf6c8132-4122-4&from=paste&height=398&id=u1fced40c&name=image.png&originHeight=796&originWidth=1300&originalType=binary&ratio=2&rotation=0&showTitle=false&size=313600&status=done&style=none&taskId=u3318e898-764b-4604-996d-d7f08ca10e7&title=&width=650",alt:"image.png"}})]),t._v(" "),a("ul",[a("li",[t._v('订单服务创建一笔新订单，将订单状态设置为"待处理"，然后让 Order Saga Orchestrator（OSO）开启创建订单事务。')]),t._v(" "),a("li",[t._v('OSO 发送一个"支付命令"给支付服务，支付服务完成扣款并回复"支付完成"消息。')]),t._v(" "),a("li",[t._v('OSO 发送一个"备货命令"给库存服务，库存服务完成库存扣减和备货，并回复"出库"消息。')]),t._v(" "),a("li",[t._v('OSO 发送一个"配送命令"给物流服务，物流服务完成配送，并回复"配送完成"消息。')]),t._v(" "),a("li",[t._v('OSO 向订单服务发送"订单结束命令"给订单服务，订单服务将订单状态设置为"完成"。')]),t._v(" "),a("li",[t._v("OSO 清楚一个订单处理 Saga 的具体流程，并在出现异常时向相关服务发送补偿命令来回滚整个分布式事务。")])]),t._v(" "),a("h4",{attrs:{id:"该模式下分布式事务的回滚-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#该模式下分布式事务的回滚-2"}},[t._v("#")]),t._v(" "),a("strong",[t._v("该模式下分布式事务的回滚")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676465054105-06ff1430-6b9f-4f71-9860-069f744d9a6e.png#averageHue=%23fbfbfa&clientId=udf6c8132-4122-4&from=paste&height=414&id=u3bd8cec5&name=image.png&originHeight=828&originWidth=1300&originalType=binary&ratio=2&rotation=0&showTitle=false&size=335488&status=done&style=none&taskId=uf73ee14b-63cb-4d6d-af0a-538e424e76e&title=&width=650",alt:"image.png"}})]),t._v(" "),a("ul",[a("li",[t._v('库存服务回复 OSO 一个"库存不足"消息。')]),t._v(" "),a("li",[t._v("OSO 意识到该分布式事务失败了，触发回滚流程：")]),t._v(" "),a("li",[t._v('OSO 发送"退款命令"给支付服务，支付服务完成退款并回复"退款成功"消息。')]),t._v(" "),a("li",[t._v('OSO 向订单服务发送"将订单状态改为失败命令"，订单服务将订单状态更新为"失败"。')])]),t._v(" "),a("h4",{attrs:{id:"基于命令方式的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于命令方式的优缺点"}},[t._v("#")]),t._v(" "),a("strong",[t._v("基于命令方式的优缺点")])]),t._v(" "),a("p",[t._v("优点：")]),t._v(" "),a("ol",[a("li",[t._v("避免了业务方之间的环形依赖。")]),t._v(" "),a("li",[t._v("将分布式事务的管理交由协调中心管理，协调中心对整个逻辑非常清楚。")]),t._v(" "),a("li",[t._v("减少了业务参与方的复杂度。这些业务参与方不再需要监听不同的消息，只是需要响应命令并回复消息。")]),t._v(" "),a("li",[t._v("测试更容易（分布式事务逻辑存在于协调中心，而不是分散在各业务方）。")]),t._v(" "),a("li",[t._v("回滚也更容易。")])]),t._v(" "),a("p",[t._v("缺点：")]),t._v(" "),a("ol",[a("li",[t._v("一个可能的缺点就是需要维护协调中心，而这个协调中心并不属于任何业务方。")])]),t._v(" "),a("h2",{attrs:{id:"本地消息表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本地消息表"}},[t._v("#")]),t._v(" 本地消息表")]),t._v(" "),a("p",[t._v("通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。")]),t._v(" "),a("p",[t._v("整体的流程如下图：\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676465416860-9754464d-a1cd-43a3-b864-2f0c22f249d7.png#averageHue=%23d3d1cf&clientId=udf6c8132-4122-4&from=paste&height=195&id=uf0c42db8&name=image.png&originHeight=390&originWidth=1080&originalType=binary&ratio=2&rotation=0&showTitle=false&size=62023&status=done&style=none&taskId=ub232f0f0-b640-4903-9b5b-93f7d96a1e0&title=&width=540",alt:"image.png"}}),t._v("\n上图中整体的处理步骤如下：")]),t._v(" "),a("ol",[a("li",[t._v("事务主动方在同一个本地事务中处理业务和写消息表操作")]),t._v(" "),a("li",[t._v("事务主动方通过消息中间件，通知事务被动方处理事务通知事务待消息。消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。")]),t._v(" "),a("li",[t._v("事务被动方通过消息中间件，通知事务主动方事务已处理的消息。")]),t._v(" "),a("li",[t._v("事务主动方接收中间件的消息，更新消息表的状态为已处理。")])]),t._v(" "),a("p",[t._v("一些必要的容错处理如下：")]),t._v(" "),a("ul",[a("li",[t._v("当 1，2 处理出错，由于还在事务主动方的本地事务中，直接回滚即可")]),t._v(" "),a("li",[t._v("当3 处 理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，事务被动方重新读取消息处理业务即可。")]),t._v(" "),a("li",[t._v("如果是业务上处理失败，事务被动方可以发消息给事务主动方回滚事务")]),t._v(" "),a("li",[t._v("如果事务被动方已经消费了消息，事务主动方需要回滚事务的话，需要发消息通知事务主动方进行回滚事务。")])]),t._v(" "),a("p",[a("strong",[t._v("优点")])]),t._v(" "),a("ul",[a("li",[t._v("从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。")]),t._v(" "),a("li",[t._v("方案轻量，容易实现。")]),t._v(" "),a("li")]),t._v(" "),a("p",[a("strong",[t._v("缺点")])]),t._v(" "),a("ul",[a("li",[t._v("与具体的业务场景绑定，耦合性强，不可公用。")]),t._v(" "),a("li",[t._v("消息数据与业务数据同库，占用业务系统资源。")]),t._v(" "),a("li",[t._v("业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。")])]),t._v(" "),a("h2",{attrs:{id:"事务消息-可靠消息事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务消息-可靠消息事务"}},[t._v("#")]),t._v(" 事务消息（可靠消息事务）")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"title"}),a("p",[t._v("基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。")])]),a("p",[t._v("事务消息方案整体流程和本地消息表的流程很相似，如下图：\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676465679908-e9031401-7019-4d1e-93f7-62b9efc407b1.png#averageHue=%23d3d2cf&clientId=udf6c8132-4122-4&from=paste&height=196&id=u4536c118&name=image.png&originHeight=391&originWidth=1080&originalType=binary&ratio=2&rotation=0&showTitle=false&size=60592&status=done&style=none&taskId=u902d024c-f14e-4cc2-81fc-9026d233cf2&title=&width=540",alt:"image.png"}}),t._v("\n从上图可以看出和本地消息表方案唯一不同就是将本地消息表存在了MQ内部，而不是业务数据库中。\n那么MQ内部的处理尤为重要，下面主要基于 RocketMQ 4.3 之后的版本介绍 MQ 的分布式事务方案。")]),t._v(" "),a("p",[t._v("在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ 的事务消息相对于普通 MQ提供了 2PC 的提交接口，方案如下：")]),t._v(" "),a("h3",{attrs:{id:"正常情况-事务主动方发消息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正常情况-事务主动方发消息"}},[t._v("#")]),t._v(" 正常情况：事务主动方发消息")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676465724222-a16c001b-ff82-4a98-b9e5-9b1d234084a9.png#averageHue=%23484848&clientId=udf6c8132-4122-4&from=paste&height=95&id=ue7e415b7&name=image.png&originHeight=190&originWidth=974&originalType=binary&ratio=2&rotation=0&showTitle=false&size=26106&status=done&style=none&taskId=u59d3af4c-0909-43a0-af3b-d0ec7b8831d&title=&width=487",alt:"image.png"}}),t._v("\n这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：")]),t._v(" "),a("ul",[a("li",[t._v("发送方向 MQ 服务端(MQ Server)发送 half 消息。")]),t._v(" "),a("li",[t._v("MQ Server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功。")]),t._v(" "),a("li",[t._v("发送方开始执行本地事务逻辑。")]),t._v(" "),a("li",[t._v("发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。")]),t._v(" "),a("li",[t._v("MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。")])]),t._v(" "),a("h3",{attrs:{id:"异常情况-事务主动方消息恢复"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异常情况-事务主动方消息恢复"}},[t._v("#")]),t._v(" 异常情况：事务主动方消息恢复")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676465814944-ba5e9596-4172-48b2-8b92-0414f3b1d12c.png#averageHue=%23545454&clientId=udf6c8132-4122-4&from=paste&height=124&id=u4e413f1c&name=image.png&originHeight=248&originWidth=1009&originalType=binary&ratio=2&rotation=0&showTitle=false&size=34315&status=done&style=none&taskId=uc2e85586-ee9a-4daf-b80c-267420c6e76&title=&width=504.5",alt:"image.png"}}),t._v("\n在断网或者应用重启等异常情况下，图中 4 提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：")]),t._v(" "),a("ul",[a("li",[t._v("MQ Server 对该消息发起消息回查。")]),t._v(" "),a("li",[t._v("发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。")]),t._v(" "),a("li",[t._v("发送方根据检查得到的本地事务的最终状态再次提交二次确认。")]),t._v(" "),a("li",[t._v("MQ Server 基于 commit/rollback 对消息进行投递或者删除。")])]),t._v(" "),a("p",[a("strong",[t._v("优点")]),t._v("\n相比本地消息表方案，MQ 事务方案优点是：")]),t._v(" "),a("ul",[a("li",[t._v("消息数据独立存储 ，降低业务系统与消息系统之间的耦合。")]),t._v(" "),a("li",[t._v("吞吐量大于使用本地消息表方案。")])]),t._v(" "),a("p",[a("strong",[t._v("缺点")])]),t._v(" "),a("ul",[a("li",[t._v("一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 。")]),t._v(" "),a("li",[t._v("业务处理服务需要实现消息状态回查接口。")])]),t._v(" "),a("h2",{attrs:{id:"最大努力通知"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最大努力通知"}},[t._v("#")]),t._v(" 最大努力通知")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"title"}),a("p",[t._v("最大努力通知也称为定期校对，是对事务消息方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到消息，此时可以调用事务主动方提供的消息校对的接口主动获取。")])]),a("p",[t._v("最大努力通知的整体流程如下图：\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/375413/1676466100233-ab58e0c8-54aa-4d12-aed7-d565c7cb0d54.png#averageHue=%23403d3a&clientId=udf6c8132-4122-4&from=paste&height=207&id=u050643aa&name=image.png&originHeight=414&originWidth=1080&originalType=binary&ratio=2&rotation=0&showTitle=false&size=74029&status=done&style=none&taskId=uae73cb63-d5b8-47ca-a634-477619d0841&title=&width=540",alt:"image.png"}}),t._v("\n在可靠消息事务中，事务主动方需要将消息发送出去，并且消息接收方成功接收，这种可靠性发送是由事务主动方保证的；")]),t._v(" "),a("p",[t._v("但是最大努力通知，事务主动方尽最大努力（重试，轮询....）将事务发送给事务接收方，但是仍然存在消息接收不到，此时需要事务被动方主动调用事务主动方的消息校对接口查询业务消息并消费，这种通知的可靠性是由事务被动方保证的。")]),t._v(" "),a("p",[t._v("最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。")]),t._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://www.pdai.tech/md/arch/arch-z-transection.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.pdai.tech/md/arch/arch-z-transection.html"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://seata.io/zh-cn/blog/tcc-mode-design-principle.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://seata.io/zh-cn/blog/tcc-mode-design-principle.html"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/wuhuachuan712/my_data_rebuild/issues/23",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/wuhuachuan712/my_data_rebuild/issues/23"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://benym.cn/archives/327/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://benym.cn/archives/327/"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1551891",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://cloud.tencent.com/developer/article/1551891"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000040934074",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://segmentfault.com/a/1190000040934074"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);