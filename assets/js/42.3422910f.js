(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{442:function(t,a,e){"use strict";e.r(a);var i=e(2),r=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("img",{attrs:{width:"600",height:"413",align:"bottom",src:"https://cdn.nlark.com/yuque/0/2023/jpeg/375413/1676015185537-a088a9b0-39f1-43e6-8bfc-6c380eced672.jpeg"}}),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"title"}),a("p",[t._v("相比于高性能、高可用架构模式在最近几十年的迅猛发展来说，可扩展架构模式的发展可以说是步履蹒跚，最近几年火热的微服务模式算是可扩展模式发展历史中为数不多的亮点，但这也导致了现在谈可扩展的时候必谈微服务，甚至微服务架构都成了架构设计的银弹")])]),a("h2",{attrs:{id:"soa-架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#soa-架构"}},[t._v("#")]),t._v(" SOA 架构")]),t._v(" "),a("p",[t._v("SOA 的全称是 Service Oriented Architecture，中文翻译为“面向服务的架构”，诞生于上世纪 90 年代，1996 年Gartner 的两位分析师 Roy W. Schulte和Yefm V. Natis 发表了第一个 SOA 的报告")]),t._v(" "),a("p",[t._v("2005年，Gartner 预言：到了 2008 年，SOA 将成为 80% 的开发项目的基础。历史证明这个预言并不十分靠谱，SOA 虽然在很多企业成功推广，但没有达到占有绝对优势的地步。SOA 更多是在传统企业（例如，制造业、金融业等）落地和推广，在互联网行业并没有大规模地实践和推广")]),t._v(" "),a("p",[t._v("SOA 出现的背景是企业内部的IT系统重复建设且效率低下，主要体现在：\n企业各部门有独立的 IT 系统，比如人力资源系统、财务系统、销售系统，这些系统可能都涉及人员管理，各 IT 系统都需要重复开发人员管理的功能。例如，某个员工离职后，需要分别到上述三个系统中删除员工的权限。各个独立的 IT 系统可能采购于不同的供应商，实现技术不同，企业自己也不太可能基于这些系统进行重构")]),t._v(" "),a("p",[t._v("随着业务的发展，复杂度越来越高，更多的流程和业务需要多个 IT 系统合作完成。由于各个独立的 IT 系统没有标准的实现方式（例如，人力资源系统用 Java 开发，对外提供 RPC；而财务系统用 C# 开发，对外提供 SOAP协议），每次开发新的流程和业务，都需要协调大量的 IT 系统，同时定制开发，效率很低。为了应对传统 IT 系统存在的问题，SOA 提出了 3 个关键概念：")]),t._v(" "),a("ol",[a("li",[t._v("服务：所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发；服务可大可小，可简单也可复杂。例如，人力资源管理可以是一项服务，包括人员基本信息管理、请假管理、组织结构管理等功能；而人员基本信息管理也可以作为一项独立的服务，组织结构管理也可以作为一项独立的服务。到底是划分为粗粒度的服务，还是划分为细粒度的服务，需要根据企业的实际情况进行判断")]),t._v(" "),a("li",[t._v("ESB：ESB 的全称是 Enterprise Service Bus，中文翻译为“企业服务总线”。从名字就可以看出，ESB 参考了计算机总线的概念。计算机中的总线将各个不同的设备连接在一起，ESB 将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。SOA 使用 ESB 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通")]),t._v(" "),a("li",[t._v("松耦合：松耦合的目的是减少各个服务间的依赖和互相影响。因为采用 SOA 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。但实际上真正做到松耦合并没有那么容易，要做到完全后向兼容，是一项复杂的任务")])]),t._v(" "),a("p",[t._v("典型的 SOA 架构样例如下：")]),t._v(" "),a("img",{attrs:{width:"500",height:"413",align:"bottom",src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650426338091-cbc40ece-e23f-4b4c-bb18-633b392a9827.png#clientId=u1a9dcbfe-9a67-4&from=paste&height=343&id=u1f6c363e&name=image.png&originHeight=540&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=434300&status=done&style=none&taskId=ude7ad7b4-963e-4995-8a69-a5a964b9fec&title=&width=542#averageHue=%23d4d5d4&id=G0Xra&originHeight=540&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="}}),t._v(" "),a("p",[t._v("SOA 架构是比较高层级的架构设计理念，一般情况下我们可以说某个企业采用了 SOA 的架构来构建 IT 系统，但不会说某个独立的系统采用了 SOA 架构。例如，某企业采用 SOA 架构，将系统分为“人力资源管理服务”“考勤服务”“财务服务”")]),t._v(" "),a("p",[t._v("SOA 解决了传统IT系统重复建设和扩展效率低的问题，但其本身也引入了更多的复杂性。SOA 最广为人诟病的就是 ESB，ESB 需要实现与各种系统间的协议转换、数据转换、透明的动态路由等功能。例如，下图中 ESB 将JSON 转换为 Java ：")]),t._v(" "),a("img",{attrs:{width:"500",height:"213",align:"bottom",src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650426419888-2c9b278d-b937-40eb-b17d-a1a1de1cc8a4.png#clientId=u1a9dcbfe-9a67-4&from=paste&height=197&id=u9770815e&name=image.png&originHeight=348&originWidth=1066&originalType=binary&ratio=1&rotation=0&showTitle=false&size=280095&status=done&style=none&taskId=u09b6027b-34ab-4798-9925-3f648154f94&title=&width=603#averageHue=%23bfbfbe&id=gE3T4&originHeight=348&originWidth=1066&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="}}),t._v(" "),a("p",[t._v("下图中 ESB 将 REST 协议转换为 RMI 和 AMQP 两个不同的协议：")]),t._v(" "),a("img",{attrs:{width:"500",height:"153",align:"bottom",src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650426454658-9ad76f0b-6d6f-4a7d-a50e-871dae268720.png#clientId=u1a9dcbfe-9a67-4&from=paste&height=191&id=u05d132ab&name=image.png&originHeight=332&originWidth=1072&originalType=binary&ratio=1&rotation=0&showTitle=false&size=220073&status=done&style=none&taskId=u3d96e284-3142-42ad-bd56-dcb95474ba0&title=&width=618#averageHue=%23d5d7d5&id=JLTG0&originHeight=332&originWidth=1072&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="}}),t._v(" "),a("p",[t._v("ESB 虽然功能强大，但现实中的协议有很多种，如 JMS、WS、HTTP、RPC等，数据格式也有很多种，如XML、JSON、二进制、HTML 等。ESB 要完成这么多协议和数据格式的互相转换，工作量和复杂度都很大，而且这种转换是需要耗费大量计算性能的，当 ESB 承载的消息太多时，ESB 本身会成为整个系统的性能瓶颈")]),t._v(" "),a("p",[t._v("当然，SOA 的 ESB 设计也是无奈之举。回想一下 SOA 的提出背景就可以发现，企业在应用 SOA 时，各种异构的IT系统都已经存在很多年了，完全重写或者按照统一标准进行改造的成本是非常大的，只能通过 ESB 方式去适配已经存在的各种异构系统")]),t._v(" "),a("h2",{attrs:{id:"微内核架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微内核架构"}},[t._v("#")]),t._v(" 微内核架构")]),t._v(" "),a("p",[t._v("微内核架构（Microkernel Architecture），也被称为"),a("strong",[t._v("插件化架构")]),t._v("（Plug-in Architecture），是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品（原文为 product-based，指存在多个版本、需要下载安装才能使用，与 web-based 相对应）的应用。例如 Eclipse 这类 IDE 软件、UNIX 这类操作系统、淘宝 App 这类客户端软件等，也有一些企业将自己的业务系统设计成微内核的架构，例如保险公司的保险核算逻辑系统，不同的保险品种可以将逻辑封装成插件")]),t._v(" "),a("h3",{attrs:{id:"基本架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本架构"}},[t._v("#")]),t._v(" 基本架构")]),t._v(" "),a("p",[t._v("微内核架构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑，例如专栏前面经常提到的“学生信息管理”系统中的“手机号注册”功能")]),t._v(" "),a("p",[t._v("微内核的基本架构示意图如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650456481931-eede4067-a587-4b61-a4f4-7c77bc512ca3.png#clientId=u385cd98d-504e-4&from=paste&height=302&id=ai74G&name=image.png&originHeight=494&originWidth=736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=387408&status=done&style=none&taskId=uc0b544f5-4936-4046-9f3c-4bfe6096578&title=&width=450",alt:"image.png"}})]),t._v(" "),a("p",[t._v("上面这张图中核心系统 Core System 功能比较稳定，不会因为业务功能扩展而不断修改，插件模块可以根据业务功能的需要不断地扩展。微内核的架构本质就是将变化部分封装在插件里面，从而达到快速灵活扩展的目的，而又不影响整体系统的稳定")]),t._v(" "),a("h3",{attrs:{id:"设计关键点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计关键点"}},[t._v("#")]),t._v(" 设计关键点")]),t._v(" "),a("p",[t._v("微内核的核心系统设计的关键技术有：插件管理、插件连接和插件通信")]),t._v(" "),a("h4",{attrs:{id:"插件管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插件管理"}},[t._v("#")]),t._v(" 插件管理")]),t._v(" "),a("p",[t._v("核心系统需要知道当前有哪些插件可用，如何加载这些插件，什么时候加载插件。常见的实现方法是插件注册表机制。核心系统提供插件注册表（可以是配置文件，也可以是代码，还可以是数据库），插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，还是按需加载）等")]),t._v(" "),a("h4",{attrs:{id:"插件连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插件连接"}},[t._v("#")]),t._v(" 插件连接")]),t._v(" "),a("p",[t._v("插件连接指插件如何连接到核心系统。通常来说，核心系统必须制定插件和核心系统的连接规范，然后插件按照规范实现，核心系统按照规范加载即可。常见的连接机制有 OSGi（Eclipse 使用）、消息模式、依赖注入（ Spring使用），甚至使用分布式的协议都是可以的，比如 RPC 或者 HTTP Web 的方式")]),t._v(" "),a("h4",{attrs:{id:"插件通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插件通信"}},[t._v("#")]),t._v(" 插件通信")]),t._v(" "),a("p",[t._v("插件通信指插件间的通信。虽然设计的时候插件间是完全解耦的，但实际业务运行过程中，必然会出现某个业务流程需要多个插件协作，这就要求两个插件间进行通信。由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。这种情况和计算机类似，计算机的 CPU、硬盘、内存、网卡是独立设计的配件，但计算机运行过程中，CPU 和内存、内存和硬盘肯定是有通信的，计算机通过主板上的总线提供了这些组件之间的通信功能。微内核的核心系统也必须提供类似的通信机制，各个插件之间才能进行正常的通信")]),t._v(" "),a("h3",{attrs:{id:"规则引擎架构简析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#规则引擎架构简析"}},[t._v("#")]),t._v(" 规则引擎架构简析")]),t._v(" "),a("p",[t._v("规则引擎从结构上来看也属于微内核架构的一种具体实现，其中执行引擎可以看作是微内核，执行引擎解析配置好的业务流，执行其中的条件和规则，通过这种方式来支持业务的灵活多变")]),t._v(" "),a("p",[t._v("规则引擎在计费、保险、促销等业务领域应用较多。例如电商促销，常见的促销规则有：")]),t._v(" "),a("ul",[a("li",[t._v("满 100 送 50")]),t._v(" "),a("li",[t._v("3 件立减 50")]),t._v(" "),a("li",[t._v("3 件 8 折")]),t._v(" "),a("li",[t._v("第 3 件免费")]),t._v(" "),a("li",[t._v("跨店满 200 减 100")]),t._v(" "),a("li",[t._v("新用户立减 50")]),t._v(" "),a("li",[t._v("……")])]),t._v(" "),a("p",[t._v("以上仅仅列出来常见的几种，实际上完整列下来可能有几十上百种，再加上排列组合，促销方案可能有几百上千种，这样的业务如果完全靠代码来实现，开发效率远远跟不上业务的\n变化速度，而规则引擎却能够很灵活的应对这种需求，主要原因在于：")]),t._v(" "),a("ol",[a("li",[t._v("可扩展：通过引入规则引擎，业务逻辑实现与业务系统分离，可以在不改动业务系统的情况下扩展新的业务功能")]),t._v(" "),a("li",[t._v("易理解：规则通过自然语言描述，业务人员易于理解和操作，而不像代码那样只有程序员才能理解和开发")]),t._v(" "),a("li",[t._v("高效率：规则引擎系统一般提供可视化的规则定制、审批、查询及管理，方便业务人员快速配置新的业务。")])]),t._v(" "),a("p",[t._v("规则引擎的基本架构如下：\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650456859921-3a119d06-9908-458f-9269-703a27847e0a.png#clientId=u385cd98d-504e-4&from=paste&height=1034&id=ufc42c848&name=image.png&originHeight=1034&originWidth=2172&originalType=binary&ratio=1&rotation=0&showTitle=false&size=807174&status=done&style=none&taskId=ub14b147a-3144-4051-bc1d-ab0d5447037&title=&width=2172",alt:"image.png"}}),t._v("\n我来简单介绍一下：\n开发人员将业务功能分解提炼为多个规则，将规则保存在规则库中。业务人员根据业务需要，通过将规则排列组合，配置成业务流程，保存在业务库中。规则引擎执行业务流程实现业务功能")]),t._v(" "),a("p",[t._v("对照微内核架构的设计关键点，我们来看看规则引擎是具体是如何实现的：")]),t._v(" "),a("ol",[a("li",[t._v("插件管理：规则引擎中的规则就是微内核架构的插件，引擎就是微内核架构的内核。规则可以被引擎加载和执行。规则引擎架构中，规则一般保存在规则库中，通常使用数据库来存储")]),t._v(" "),a("li",[t._v("插件连接：类似于程序员开发的时候需要采用 Java、C++ 等语言，规则引擎也规定了规则开发的语言，业务人员需要基于规则语言来编写规则文件，然后由规则引擎加载执行规则文件来完成业务功能，因此，规则引擎的插件连接实现机制其实就是规则语言")]),t._v(" "),a("li",[t._v("插件通信：规则引擎的规则之间进行通信的方式就是数据流和事件流，由于单个规则并不需要依赖其他规则，因此规则之间没有主动的通信，规则只需要输出数据或者事件，由引擎将数据或者事件传递到下一个规则")])]),t._v(" "),a("p",[t._v("目前最常用的规则引擎是开源的 JBoss Drools，采用 Java 语言编写，基于 Rete 算法")]),t._v(" "),a("h2",{attrs:{id:"微服务架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务架构"}},[t._v("#")]),t._v(" 微服务架构")]),t._v(" "),a("h3",{attrs:{id:"兴起"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#兴起"}},[t._v("#")]),t._v(" 兴起")]),t._v(" "),a("p",[t._v("微服务是近几年非常火热的架构设计理念，大部分人认为是 Martin Fowler 提出了微服务概念，但事实上微服务概念的历史要早得多，也不是 Martin Fowler 创造出来的，Martin 只是将微服务进行了系统的阐述（原文链接："),a("a",{attrs:{href:"https://martinfowler.com/articles/microservices.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://martinfowler.com/articles/microservices.html"),a("OutboundLink")],1),t._v("）。不过不能否认 Martin 在推动微服务起到的作用，微服务能火，Martin 功不可没")]),t._v(" "),a("p",[t._v("微服务的定义相信你早已耳熟能详，参考维基百科，我就来简单梳理一下微服务的历史吧")]),t._v(" "),a("ul",[a("li",[t._v("2005 年：Dr. Peter Rodgers 在 Web Services Edge 大会上提出了 “Micro-Web-Services” 的概念")]),t._v(" "),a("li",[t._v("2011 年：一个软件架构工作组使用了 “microservice” 一词来描述一种架构模式")]),t._v(" "),a("li",[t._v("2012 年：同样是这个架构工作组，正式确定用 “microservice” 来代表这种架构")]),t._v(" "),a("li",[t._v("2012 年：ThoughtWorks 的 James Lewis 针对微服务概念在 QCon San Francisco 2012 发表了演讲")]),t._v(" "),a("li",[t._v("2014 年：James Lewis 和 Martin Fowler 合写了关于微服务的一篇学术性的文章，详细阐述了微服务")])]),t._v(" "),a("p",[t._v("由于微服务的理念中也包含了“服务”的概念，而 SOA 中也有“服务”的概念，我们自然而然地会提出疑问：微服务与 SOA 有什么关系？有什么区别？为何有了 SOA 还要提微服务？这几个问题是理解微服务的关键，否则如果只是跟风拿来就用，既不会用，也用不好，用了不但没有效果，反而还可能有副作用")]),t._v(" "),a("h3",{attrs:{id:"微服务与-soa-的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务与-soa-的关系"}},[t._v("#")]),t._v(" 微服务与 SOA 的关系")]),t._v(" "),a("p",[t._v("对于了解过 SOA 的人来说，第一次看到微服务这个概念肯定会有所疑惑：为何有了 SOA 还要提微服务呢？等到简单看完微服务的介绍后，可能很多人更困惑了：这不就是 SOA 吗？\n关于 SOA 和微服务的关系和区别，大概分为下面几个典型的观点：")]),t._v(" "),a("h4",{attrs:{id:"微服务是-soa-的实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务是-soa-的实现方式"}},[t._v("#")]),t._v(" 微服务是 SOA 的实现方式")]),t._v(" "),a("p",[t._v("如下图所示，这种观点认为 SOA 是一种架构理念，而微服务是 SOA 理念的一种具体实现方法。例如，“微服务就是使用 HTTP RESTful 协议来实现 ESB 的 SOA")]),t._v(" "),a("img",{attrs:{width:"300",height:"213",align:"bottom",src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650433381777-056b4915-2f19-4d28-a590-5bd196a7fd0e.png#clientId=u97deff43-ec1a-4&from=paste&height=125&id=u0c422a88&name=image.png&originHeight=320&originWidth=696&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146688&status=done&style=none&taskId=u2b2e7cf8-5a74-4d17-8fc9-2a2c63a7ff9&title=&width=272"}}),t._v(" "),a("h4",{attrs:{id:"微服务是去掉-esb-后的-soa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务是去掉-esb-后的-soa"}},[t._v("#")]),t._v(" 微服务是去掉 ESB 后的 SOA")]),t._v(" "),a("p",[t._v("如下图所示，这种观点认为传统 SOA 架构最广为人诟病的就是庞大、复杂、低效的 ESB，因此将 ESB 去掉，改为轻量级的 HTTP 实现，就是微服务：")]),t._v(" "),a("img",{attrs:{width:"300",height:"213",align:"bottom",src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650433438173-a10e70ca-7eb5-416f-898b-ffa128503310.png#clientId=u97deff43-ec1a-4&from=paste&height=160&id=u093487b9&name=image.png&originHeight=356&originWidth=706&originalType=binary&ratio=1&rotation=0&showTitle=false&size=170734&status=done&style=none&taskId=u2f36c002-7cff-4386-b987-08e40d878b2&title=&width=318"}}),t._v(" "),a("h4",{attrs:{id:"微服务是一种和-soa-相似但本质上不同的架构理念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务是一种和-soa-相似但本质上不同的架构理念"}},[t._v("#")]),t._v(" 微服务是一种和 SOA 相似但本质上不同的架构理念")]),t._v(" "),a("p",[t._v("如下图所示，这种观点认为微服务和 SOA 只是有点类似，但本质上是不同的架构设计理念。相似点在于下图中交叉的地方，就是两者都关注“服务”，都是通过服务的拆分来解决可扩展性问题。本质上不同的地方在于几个核心理念的差异：是否有 ESB、服务的粒度、架构设计的目标等")]),t._v(" "),a("img",{attrs:{width:"300",height:"213",align:"bottom",src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650433612554-aa7f2896-f917-4661-9ce9-483f8edae082.png#clientId=u02cac1ff-9a0e-4&from=paste&height=180&id=u15c69110&name=image.png&originHeight=326&originWidth=858&originalType=binary&ratio=1&rotation=0&showTitle=false&size=181844&status=done&style=none&taskId=ud1962bf3-8b71-4a45-9f78-000da6970f2&title=&width=473"}}),t._v(" "),a("p",[t._v("以上观点看似都有一定的道理，但都有点差别，到底哪个才是准确的呢？单纯从概念上是难以分辨的，我来对比一下 SOA 和微服务的一些具体做法，再来看看到底哪一种观点更加符合实际情况")]),t._v(" "),a("ol",[a("li",[t._v("服务粒度：整体上来说，SOA 的服务粒度要粗一些，而微服务的服务粒度要细一些。例如，对一个大型企业来说，“员工管理系统”就是一个 SOA 架构中的服务；而如果采用微服务架构，则“员工管理系统”会被拆分为更多的服务，比如“员工信息管理”“员工考勤管理”“员工假期管理”和“员工福利管理”等更多服务")]),t._v(" "),a("li",[t._v("服务通信：SOA 采用了 ESB 作为服务间通信的关键组件，负责服务定义、服务路由、消息转换、消息传递，总体上是重量级的实现。微服务推荐使用统一的协议和格式，例如，RESTful 协议、RPC 协议，无须 ESB 这样的重量级实现")]),t._v(" "),a("li",[t._v("服务交付：SOA 对服务的交付并没有特殊要求，因为 SOA 更多考虑的是兼容已有的系统；微服务的架构理念要求“快速交付”，相应地要求采取自动化测试、持续集成、自动化部署等敏捷开发相关的最佳实践。如果没有这些基础能力支撑，微服务规模一旦变大（例如，超过 20 个微服务），整体就难以达到快速交付的要求，这也是很多企业在实行微服务时踩过的一个明显的坑，就是系统拆分为微服务后，部署的成本呈指数上升")]),t._v(" "),a("li",[t._v("应用场景：SOA 更加适合于庞大、复杂、异构的企业级系统，这也是 SOA 诞生的背景。这类系统的典型特征就是很多系统已经发展多年，采用不同的企业级技术，有的是内部开发的，有的是外部购买的，无法完全推倒重来或者进行大规模的优化和重构。因为成本和影响太大，只能采用兼容的方式进行处理，而承担兼容任务的就是 ESB。微服务更加适合于快速、轻量级、基于 Web 的互联网系统，这类系统业务变化快，需要快速尝试、快速交付；同时基本都是基于 Web，虽然开发技术可能差异很大（例如，Java、C++、.NET 等），但对外接口基本都是提供 HTTP RESTful 风格的接口，无须考虑在接口层进行类似 SOA 的 ESB 那样的处理。")])]),t._v(" "),a("p",[t._v("综合上述分析，我将 SOA 和微服务对比如下：\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650433840359-fbe99f2a-449d-4e7a-ae82-87a531a264d5.png#clientId=uc55e9df2-0fd7-4&from=paste&height=161&id=u8f04be4c&name=image.png&originHeight=296&originWidth=1154&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126892&status=done&style=none&taskId=udde100dd-d818-451a-86af-adcb5cb7dab&title=&width=629",alt:"image.png"}}),t._v("\n因此，我们可以看到，SOA 和微服务本质上是两种不同的架构设计理念，只是在“服务”这个点上有交集而已，因此两者的关系应该是上面第三种观点")]),t._v(" "),a("p",[t._v("通过前面的详细分析和比较，似乎微服务本质上就是一种比 SOA 要优秀很多的架构模式，那是否意味着我们都应该把架构重构为微服务呢？其实不然，SOA 和微服务是两种不同理念的架构模式，并不存在孰优孰劣，只是应用场景不同而已。我们介绍 SOA 时候提到其产生历史背景是因为企业的IT服务系统庞大而又复杂，改造成本很高，但业务上又要求其互通，因此才会提出 SOA 这种解决方案。如果我们将微服务的架构模式生搬硬套到企业级 IT 服务系统中，这些 IT 服务系统的改造成本可能远远超出实施 SOA 的成本")]),t._v(" "),a("h3",{attrs:{id:"微服务的陷阱"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务的陷阱"}},[t._v("#")]),t._v(" 微服务的陷阱")]),t._v(" "),a("p",[t._v("单纯从上面的对比来看，似乎微服务大大优于 SOA ，这也导致了很多团队在实践时不加思考地采用微服务——既不考虑团队的规模，也不考虑业务的发展，也没有考虑基础技术的支撑，只是觉得微服务很牛就赶紧来实施，以为实施了微服务后就什么问题都解决了，而一旦真正实施后才发现掉到微服务的坑里面去了\n我们看一下微服务具体有哪些坑：")]),t._v(" "),a("h4",{attrs:{id:"服务划分过细-服务间关系复杂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务划分过细-服务间关系复杂"}},[t._v("#")]),t._v(" 服务划分过细，服务间关系复杂")]),t._v(" "),a("p",[t._v("服务划分过细，单个服务的复杂度确实下降了，但整个系统的复杂度却上升了，因为微服务将系统内的复杂度转移为系统间的复杂度了。从理论的角度来计算，n 个服务的复杂度是 n × (n -1 ) / 2 ，整体系统的复杂度是随着微服务数量的增加呈指数级增加的。下图形象了说明了整体复杂度：\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650434080917-1140ed86-711f-456f-9d6a-261562ba8a23.png#clientId=u1c4b53a9-282c-4&from=paste&height=215&id=ubc002268&name=image.png&originHeight=420&originWidth=1016&originalType=binary&ratio=1&rotation=0&showTitle=false&size=288266&status=done&style=none&taskId=u06ad1cd2-5888-4836-bc55-b03fa3e440f&title=&width=520",alt:"image.png"}})]),t._v(" "),a("h4",{attrs:{id:"服务数量太多-团队效率急剧下降"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务数量太多-团队效率急剧下降"}},[t._v("#")]),t._v(" 服务数量太多，团队效率急剧下降")]),t._v(" "),a("p",[t._v("微服务的“微”字，本身就是一个陷阱，很多团队看到“微”字后，就想到必须将服务拆分得很细，有的团队人员规模是 5 ~ 6 个人，然而却拆分出 30 多个微服务，平均每个人要维护 5 个以上的微服务")]),t._v(" "),a("p",[t._v("这样做给工作效率带来了明显的影响，一个简单的需求开发就需要涉及多个微服务，光是微服务之间的接口就有 6 ~ 7 个，无论是设计、开发、测试、部署，都需要工程师不停地在不同的服务间切换")]),t._v(" "),a("ol",[a("li",[t._v("开发工程师要设计多个接口，打开多个工程，调试时要部署多个程序，提测时打多个包")]),t._v(" "),a("li",[t._v("测试工程师要部署多个环境，准备多个微服务的数据，测试多个接口")]),t._v(" "),a("li",[t._v("运维工程师每次上线都要操作多个微服务，并且微服务之间可能还有依赖关系")])]),t._v(" "),a("h4",{attrs:{id:"调用链太长-性能下降"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用链太长-性能下降"}},[t._v("#")]),t._v(" 调用链太长，性能下降")]),t._v(" "),a("p",[t._v("由于微服务之间都是通过 HTTP 或者 RPC 调用的，每次调用必须经过网络。一般线上的业务接口之间的调用，平均响应时间大约为 50 毫秒，如果用户的一起请求需要经过 6 次微服务调用，则性能消耗就是 300 毫秒，这在很多高性能业务场景下是难以满足需求的。为了支撑业务请求，可能需要大幅增加硬件，这就导致了硬件成本的大幅上升")]),t._v(" "),a("h4",{attrs:{id:"调用链太长-问题定位困难"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用链太长-问题定位困难"}},[t._v("#")]),t._v(" 调用链太长，问题定位困难")]),t._v(" "),a("p",[t._v("系统拆分为微服务后，一次用户请求需要多个微服务协同处理，任意微服务的故障都将导致整个业务失败。然而由于微服务数量较多，且故障存在扩散现象，快速定位到底是哪个微服务故障是一件复杂的事情。下面是一个典型样例\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650434918604-607908ca-4322-4c33-a61b-fb614071e52e.png#clientId=u1c4b53a9-282c-4&from=paste&height=237&id=u3e55527d&name=image.png&originHeight=486&originWidth=1058&originalType=binary&ratio=1&rotation=0&showTitle=false&size=205044&status=done&style=none&taskId=u501f36df-1118-4bf5-9763-67604e1e28a&title=&width=517",alt:"image.png"}}),t._v("\nService C 的数据库出现慢查询，导致 Service C 给 Service B 的响应错误，Service B 给 Service A 的响应错误，Service A 给用户的响应错误。我们在实际定位时是不会有样例图中这么清晰的，最开始是用户报错，这时我们首先会去查 Service A。导致 Service A 故障的原因有很多，我们可能要花半个小时甚至1个小时才能发现是 Service B 返回错误导致的。于是我们又去查 Service B，这相当于重复 Service A 故障定位的步骤……如此循环下去，最后可能花费了几个小时才能定位到是 Service C 的数据库慢查询导致了错误")]),t._v(" "),a("h4",{attrs:{id:"没有自动化支撑-无法快速交付"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#没有自动化支撑-无法快速交付"}},[t._v("#")]),t._v(" 没有自动化支撑，无法快速交付")]),t._v(" "),a("p",[t._v("如果没有相应的自动化系统进行支撑，都是靠人工去操作，那么微服务不但达不到快速交付的目的，甚至还不如一个大而全的系统效率高。例如：")]),t._v(" "),a("ol",[a("li",[t._v("没有自动化测试支撑，每次测试时需要测试大量接口。")]),t._v(" "),a("li",[t._v("没有自动化部署支撑，每次部署6 ~ 7个服务，几十台机器，运维人员敲 shell 命令逐台部署，手都要敲麻")]),t._v(" "),a("li",[t._v("没有自动化监控，每次故障定位都需要人工查几十台机器几百个微服务的各种状态和各种日志文件")])]),t._v(" "),a("h4",{attrs:{id:"没有服务治理-微服务数量多了后管理混乱"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#没有服务治理-微服务数量多了后管理混乱"}},[t._v("#")]),t._v(" 没有服务治理，微服务数量多了后管理混乱")]),t._v(" "),a("p",[t._v("信奉微服务理念的设计人员总是强调微服务的 lightweight 特性，并举出 ESB 的反例来证明微服务的优越之处。但具体实践后就会发现，随着微服务种类和数量越来越多，如果没有服务治理系统进行支撑，微服务提倡的lightweight 就会变成问题。主要问题有：")]),t._v(" "),a("ol",[a("li",[t._v("服务路由：假设某个微服务有 60 个节点，部署在 20 台机器上，那么其他依赖的微服务如何知道这个部署情况呢？")]),t._v(" "),a("li",[t._v("服务故障隔离：假设上述例子中的 60 个节点有 5 个节点发生故障了，依赖的微服务如何处理这种情况呢？")]),t._v(" "),a("li",[t._v("服务注册和发现：同样是上述的例子，现在我们决定从 60 个节点扩容到 80 个节点，或者将 60 个节点缩减为40 个节点，新增或者减少的节点如何让依赖的服务知道呢？")])]),t._v(" "),a("p",[t._v("如果以上场景都依赖人工去管理，整个系统将陷入一片混乱，最终的解决方案必须依赖自动化的服务管理系统，这时就会发现，微服务所推崇的 “lightweight”，最终也发展成和 ESB 几乎一样的复杂程度")]),t._v(" "),a("h3",{attrs:{id:"微服务实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务实践"}},[t._v("#")]),t._v(" 微服务实践")]),t._v(" "),a("h4",{attrs:{id:"服务粒度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务粒度"}},[t._v("#")]),t._v(" 服务粒度")]),t._v(" "),a("p",[t._v("针对微服务拆分过细导致的问题，我建议基于团队规模进行拆分，类似贝索斯在定义团队规模时提出的“两个披萨”理论（每个团队的人数不能多到两张披萨都不够吃的地步），分享一个我认为微服务拆分粒度的 "),a("strong",[t._v("“三个火枪手”原则")]),t._v("，即一个微服务三个人负责开发。当我们在实施微服务架构时，根据团队规模来划分微服务数量，如果业务规继续发展，团队规模扩大，我们再将已有的微服务进行拆分。例如，团队最初有6个人，那么可以划分为2个微服务，随着业务的发展，业务功能越来越多，逻辑越来越复杂，团队扩展到12个人，那么我们可以将已有的2个微服务进行拆分，变成4个微服务")]),t._v(" "),a("p",[t._v("为什么是3个人，不是4个，也不是2个呢？")]),t._v(" "),a("ul",[a("li",[t._v("首先，从系统规模来讲，3个人负责开发一个系统，系统的复杂度刚好达到每个人都能全面理解整个系统，又能够进行分工的粒度；如果是2个人开发一个系统，系统的复杂度不够，开发人员可能觉得无法体现自己的技术实力；如果是4个甚至更多人开发一个系统，系统复杂度又会无法让开发人员对系统的细节都了解很深。")]),t._v(" "),a("li",[t._v("其次，从团队管理来说，3个人可以形成一个稳定的备份，即使1个人休假或者调配到其他系统，剩余2个人还可以支撑；如果是2个人，抽调1个后剩余的1个人压力很大；如果是1个人，这就是单点了，团队没有备份，某些情况下是很危险的，假如这个人休假了，系统出问题了怎么办？")]),t._v(" "),a("li",[t._v("最后，从技术提升的角度来讲，3个人的技术小组既能够形成有效的讨论，又能够快速达成一致意见；如果是2个人，可能会出现互相坚持自己的意见，或者2个人经验都不足导致设计缺陷；如果是1个人，由于没有人跟他进行技术讨论，很可能陷入思维盲区导致重大问题；如果是4个人或者更多，可能有的参与的人员并没有认真参与，只是完成任务而已。")])]),t._v(" "),a("p",[t._v("“三个火枪手”的原则主要应用于微服务设计和开发阶段，如果微服务经过一段时间发展后已经比较稳定，处于维护期了，无须太多的开发，那么平均1个人维护1个微服务甚至几个微服务都可以。当然考虑到人员备份问题，每个微服务最好都安排2个人维护，每个人都可以维护多个微服务")]),t._v(" "),a("h4",{attrs:{id:"拆分方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拆分方法"}},[t._v("#")]),t._v(" 拆分方法")]),t._v(" "),a("p",[t._v("基于“三个火枪手”的理论，我们可以计算出拆分后合适的服务数量，但具体怎么拆也是有技巧的，并不是快刀砍乱麻随便拆分成指定数量的微服务就可以了，也不是只能按照业务来进行拆分，而是可以根据目的的不同灵活地选取不同的拆分方式。接下来我一一介绍常见的拆分方式")]),t._v(" "),a("h5",{attrs:{id:"基于业务逻辑拆分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于业务逻辑拆分"}},[t._v("#")]),t._v(" 基于业务逻辑拆分")]),t._v(" "),a("p",[t._v("这是最常见的一种拆分方式，将系统中的业务模块按照职责范围识别出来，每个单独的业务模块拆分为一个独立的服务。基于业务逻辑拆分虽然看起来很直观，但在实践过程中最常见的一个问题就是团队成员对于“职责范围”的理解差异很大，经常会出现争论，难以达成一致意见。例如：假设我们做一个电商系统，第一种方式是将服务划分为“商品”“交易”“用户”3个服务，第二种方式是划分为“商品”“订单”“支付”“发货”“买家”“卖家”6个服务，哪种方式更合理，是不是划分越细越正确？")]),t._v(" "),a("p",[t._v("导致这种困惑的主要根因在于从业务的角度来拆分的话，规模粗和规模细都没有问题，因为拆分基础都是业务逻辑，要判断拆分粒度，不能从业务逻辑角度，而要根据前面介绍的“三个火枪手”的原则，计算一下大概的服务数量范围，然后再确定合适的“职责范围”，否则就可能出现划分过粗或者过细的情况，而且大部分情况下会出现过细的情况")]),t._v(" "),a("p",[t._v("例如：如果团队规模是10个人支撑业务，按照“三个火枪手”规则计算，大约需要划分为4个服务，那么“登录、注册、用户信息管理”都可以划到“用户服务”职责范围内；如果团队规模是100人支撑业务，服务数量可以达到40个，那么“用户登录“就是一个服务了；如果团队规模达到1000人支撑业务，那“用户连接管理”可能就是一个独立的服务了")]),t._v(" "),a("h5",{attrs:{id:"基于可扩展拆分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于可扩展拆分"}},[t._v("#")]),t._v(" 基于可扩展拆分")]),t._v(" "),a("p",[t._v("将系统中的业务模块按照稳定性排序，将已经成熟和改动不大的服务拆分为稳定服务，将经常变化和迭代的服务拆分为变动服务。稳定的服务粒度可以粗一些，即使逻辑上没有强关联的服务，也可以放在同一个子系统中，例如将“日志服务”和“升级服务”放在同一个子系统中；不稳定的服务粒度可以细一些，但也不要太细，始终记住要控制服务的总数量。这样拆分主要是为了提升项目快速迭代的效率，避免在开发的时候，不小心影响了已有的成熟功能导致线上问题")]),t._v(" "),a("h5",{attrs:{id:"基于可靠性拆分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于可靠性拆分"}},[t._v("#")]),t._v(" 基于可靠性拆分")]),t._v(" "),a("p",[t._v("将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。具体拆分的时候，核心服务可以是一个也可以是多个，只要最终的服务数量满足“三个火枪手”的原则就可以。这样拆分带来下面几个好处：")]),t._v(" "),a("ul",[a("li",[t._v("避免非核心服务故障影响核心服务：例如，日志上报一般都属于非核心服务，但是在某些场景下可能有大量的日志上报，如果系统没有拆分，那么日志上报可能导致核心服务故障；拆分后即使日志上报有问题，也不会影响核心服务")]),t._v(" "),a("li",[t._v("核心服务高可用方案可以更简单：核心服务的功能逻辑更加简单，存储的数据可能更少，用到的组件也会更少，设计高可用方案大部分情况下要比不拆分简单很多")]),t._v(" "),a("li",[t._v("能够降低高可用成本：将核心服务拆分出来后，核心服务占用的机器、带宽等资源比不拆分要少很多。因此，只针对核心服务做高可用方案，机器、带宽等成本比不拆分要节省较多")])]),t._v(" "),a("h5",{attrs:{id:"基于性能拆分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于性能拆分"}},[t._v("#")]),t._v(" 基于性能拆分")]),t._v(" "),a("p",[t._v("基于性能拆分和基于可靠性拆分类似，将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务。常见的拆分方式和具体的性能瓶颈有关，可以拆分Web服务、数据库、缓存等。例如电商的抢购，性能压力最大的是入口的排队功能，可以将排队功能独立为一个服务")]),t._v(" "),a("p",[t._v("以上几种拆分方式不是多选一，而是可以根据实际情况自由排列组合，例如可以基于可靠性拆分出服务 A，基于性能拆分出服务 B，基于可扩展拆分出 C/D/F 三个服务，加上原有的服务 X ，最后总共拆分出 6 个服务（A/B/C/D/F/X）")]),t._v(" "),a("h4",{attrs:{id:"基础设施"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础设施"}},[t._v("#")]),t._v(" 基础设施")]),t._v(" "),a("p",[t._v("大部分人主要关注的是微服务的 “small” 和 “lightweight” 特性，但实际上真正决定微服务成败的，恰恰是那个被大部分人都忽略的 “automated” 。为何这样说呢？因为服务粒度即使划分不合理，实际落地后如果团队遇到麻烦，自然会想到拆服务或者合服务；如果 “automated” 相关的基础设施不健全，那微服务就是焦油坑，让研发、测试、运维陷入我上一期讲的各种微服务陷阱中\n微服务基础设施如下图所示：")]),t._v(" "),a("img",{attrs:{width:"400",height:"313",align:"bottom",src:"https://cdn.nlark.com/yuque/0/2022/png/375413/1650454960552-3f0bad0c-dc5d-4720-ab8b-1f4403e4d0d6.png#clientId=u24e58e0a-e722-4&from=paste&height=295&id=u67aeaacb&name=image.png&originHeight=658&originWidth=902&originalType=binary&ratio=1&rotation=0&showTitle=false&size=492342&status=done&style=none&taskId=ucb8c2094-3320-434f-a358-ea57d41fff5&title=&width=404"}}),t._v(" "),a("p",[t._v("看到上面这张图，相信很多人都会倒吸一口凉气，说好的微服务的“轻量级”呢？都这么多基础设施还好意思说自己是“轻量级”，感觉比ESB还要复杂啊？确实如此，微服务并不是很多人认为的那样又简单又轻量级。要做好微服务，这些基础设施都是必不可少的，否则微服务就会变成一个焦油坑，让业务和团队在里面不断挣扎且无法\n自拔。因此也可以说，微服务并没有减少复杂度，而只是将复杂度从ESB转移到了基础设施。你可以看到，“服务发现”“服务路由”等其实都是 ESB 的功能，只是在微服务中剥离出来成了独立的基础系统")]),t._v(" "),a("p",[t._v("虽然建设完善的微服务基础设施是一项庞大的工程，但也不用太过灰心，认为自己团队小或者公司规模不大就不能实施微服务了。第一个原因是已经有开源的微服务基础设施全家桶了，例如大名鼎鼎的 Spring Cloud 项目，涵盖了服务发现、服务路由、网关、配置中心等功能；第二个原因是如果微服务的数量并不是很多的话，并不是每个基础设施都是必须的。通常情况下，我建议按照下面优先级来搭建基础设施：")]),t._v(" "),a("ol",[a("li",[t._v("服务发现、服务路由、服务容错：这是最基本的微服务基础设施")]),t._v(" "),a("li",[t._v("接口框架、API网关：主要是为了提升开发效率，接口框架是提升内部服务的开发效率，API网关是为了提升与外部服务对接的效率")]),t._v(" "),a("li",[t._v("自动化部署、自动化测试、配置中心：主要是为了提升测试和运维效率")]),t._v(" "),a("li",[t._v("服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率。")])]),t._v(" "),a("p",[t._v("以上3和4两类基础设施，其重要性会随着微服务节点数量增加而越来越重要，但在微服务节点数量较少的时候，可以通过人工的方式支撑，虽然效率不高，但也基本能够顶住")]),t._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("ol",[a("li",[t._v("《从 0 开始学架构》")])])])}),[],!1,null,null,null);a.default=r.exports}}]);